# 从输入url到页面展示发生了什么？ 

## 1. 用户输入

用户输入查询关键字后，地址栏会判断输入的关键字是搜索内容还是请求的URL。

- 如果是搜索内容， 地址栏会使用浏览器默认的搜索引擎， 来合成带关键字的 url。
- 如果输入的内容符合 url 规则， 地址栏会根据规则把内容加上协议， 合成完整的 url。

> 当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。
> 当前页面没有监听 beforeunload 事件或者同意了继续后续流程，那么浏览器就进入加载状态。

总结: 浏览器进程处理完URL后， 浏览器进程会发出URL请求给网络进程。

## 2. 网络请求

接下来, 便进入了页面资源请求过程。 这是浏览器会通过进程间通信(IPC)把URL请求发送至网络进程，网络进程接收到URL请求后， 会在这里发起真正的URL请求流程。

首先， 网络进程会查找本地缓存资源。如果存在缓存资源，

1. 浏览器缓存

俩个概念: 强缓存和协商缓存。

<b>服务端缓存控制:</b> 

强缓存与服务端的缓存控制息息相关，启用强缓存有以下几种情况。

- 存在 Cache-Control 属性， 设置 max-age 属性值并且不存在 no-cache 和 no-store
- 不存在 Cache-Control 属性 存在expires 字段。

> 服务端缓存控制有以下几种状态：
>
> no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；
> no-cache：可以缓存，但在使用之前必须要去服务器验证是否过期，是否存在新的版本（如果存在新版本，使用新版本，如果不存在新版本使用本地缓存）；
> must-revalidate：如果缓存不过期就可以继续使用，过期了如果还想用就去服务器验证；
>
> 还有两个和缓存代理相关的属性。
>
> private：表示缓存只能在客户端保存，是用户“私有”的，不能通过代理服务器缓存，与别人分享；
> public：缓存完全开放，代理服务器随便缓存，谁都可以存，谁都可以用；

<b>客户端缓存控制: </b>

> 进入协商缓存之前， 还需要经过 DNS 解析，建立 TCP/IP 连接， 如果是 https 协议还需 TLS 连接。

协商缓存由客户端发起 (条件请求), 如果没有命中强缓存， 就会进入协商缓存阶段。

条件请求一共有5个头字段， 我们最常用的就是 "if-Modified-Since" 和 "if-None-Match" 这俩个。
使用的前提是需要第一次的响应报文预先提供 "Last-modified" 和 "Etag", 然后第二次请求就可以带上缓存里的原值， 验证资源是否最新的。

> 如果响应报文里提供了"Last-modified", 但没有 "Cache-Control" 或 "Expires", 浏览器会使用 "启发" (Heuristic)算法计算一个缓存时间，在RFC里的建议是: (Date - Last-modified) * 10%。
>
> Etag 还有强弱之分，强ETag要求资源在字节级别必须完全相符，弱 Etag 在值前面有个 "W/" 标记， 只有求资源在语义化上没有变化， 但内部可能会有部分发生改变 (例如 HTML 里的标签顺序调整， 或者多了几个空格。)
>
> 条件请求里其他的三个头字段是 "If-Unmodified-Since" 、"If-Match" 和 "If-Range", 和 "if-Modified-Since" 和 "if-None-Match"用法一致。

如果资源没有变化， 服务器就会回应 "304 Not Modified"， 表示缓存依然有效。
请求过程中还可能发生另一种情况， 那就是服务器返回状态码 301、 302。

<b>重定向: </b>

重定向是由服务器发起的，浏览器使用者无法控制，浏览器收到 301、302 这两个状态码就会跳转到新的 URI。

其实除了状态码之外，要想实现重定向还需要 “Location”字段的配合。

> Connection: keep-alive
> Content-Length: 151
> Content-Type: text/html
> Date: Sun, 21 Feb 2021 00:48:52 GMT
> Location: /index.html
> Referer: /18-1
> Server: openresty/1.19.3.1

"Location" 字段属于响应字段， 必须出现在响应报文里，但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI，这里就是要求浏览器跳转到“index.html”。
浏览器收到 301/302 报文，会检查响应头里有没有“Location”。如果有，就从字段值里提取出 URI，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

> “Location”里的 URI 既可以使用绝对 URI，也可以使用相对 URI。
> 如果重定向只在站内跳转，可以使用相对 URI。如果跳转到站外，必须使用绝对 URI。
> 重定向报文里还可以用 Refresh 字段，实现延时重定向，例如“Refresh:5; url=xxx” 告诉浏览器 5 秒后再跳转。

### 2. DNS解析

上面说到浏览器缓存，首先，网络进程会查找本地缓存是否缓存资源。
如果存在缓存资源，就直接返回资源给浏览器进程。如果不存在缓存，这时就要判断是否需要 DNS 解析。

首先判断 URI 是否是一个域名，如果是一个域名，走 DNS 解析流程，获取服务器的 IP 地址。

<b>DNS系统</b>

DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构。

- 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；
- 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；
- 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址；

![](https://img.yueluo.club/blog/img/10348d57b7f6733ddd1029658c14f5e9f0.png)

有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。

在核心系统之外，还有两种缓存手段来减轻域名解析的压力，可以更快地获取结果。

- 许多大公司、网络运营商都会建立自己的 DNS 服务器，代替用户访问核心 DNS 系统。这些“野生服务器”都被称为“非权威域名服务器”。
- 操作系统也会对 DNS 解析结果缓存。操作系统里还有一个特殊的“主机映射文件”，即 Linux 中的“/etc/hosts”，Windows 中的“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。

另外浏览器也会对 DNS 缓存的结果进行缓存，缓存策略和浏览器相关。

<b>DNS解析流程: </b>

> 浏览器缓存 -> 操作系统缓存 -> 本地hosts文件 -> 非权威域名服务器 -> 根域名服务器 -> 顶级域名服务器 -> 权威域名服务器。
>
> win10 启动加载时，会把 hosts 中的条目缓存在操作系统中。
> win10 还会监听 hosts 文件的变化，并动态更新操作系统缓存。

### 3. 建立TCP/IP连接

获取到服务器的IP地址后， 就可以建立 TCP/IP连接。

网络分层模型

![](https://img.yueluo.club/blog/img/da723a6d26ae8c99a23fa6fc1a31fe310.png)

TCP/IP 协议总共有四层，它的层次顺序是“从下往上”数的，第一层是最下面的一层。

第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的的底层数据上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。

第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。

第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输。TCP 协议就位于这一层，另外还有 UDP 也位于这一层。

第四层叫“应用层”（application layer）。这一层有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等。当然还有最常见的 HTTP 协议。

<b>三次握手</b>

名词解析: 

- ACK: Acknowledement 确认字符
- SYN: Synchronize Sequence Numbers 同步序列编号

状态: 

- LISTEN: 监听TCP端口的连接请求。 (等待对方发送连接请求)
- SYN-SENT： 发送连接请求等待匹配连接请求。 （已发送请求等待回复）
- SYN-RECEIVED: 收到和发送一个连接请求等待对连接请求的确认 (收到连接请求， 等待回复)
- ESTABLISHED: 已经打开连接（已经建立连接，可以发送数据）

![](https://img.yueluo.club/blog/img/c1083ff9ef7310d84349b1fb6b30ac6be.png)

流程总结: 
1. 客户端首先向服务器发送 SYN 标志位（序号为J）的连接请求， 并将状态切换到 SYN-SENT 状态。
2. 服务器处于 LISTEN 状态， 当收到 客户端发送的 SYN J 连接请求后，确认收到数据包， 并发送 ACK(J+1) 和 SYN（K）, 服务器进入 SYN-RECEIVED状态。
3. 客户端进入ESTABLISHED连接状态， 并发送 确认 ACK(K + 1)， 确认客户端收到，并建立连接。 服务端收到后进入ESTABLISHED.

> 这里的序号 J，K 都代表一个序列号，三次握手的最重要的是交换彼此的 ISN（初始序列号）。
>
> SYN 报文不携带数据，但是它占用一个序号，下次发送数据序列号要加一。
> 客户端会随机选择一个数字作为初始序列号（ISN）。
>
> ACK 用来告知发送端之前发送的 SYN 段已经收到了，字段指定了发送端下次发送段的序号。

在HTTP协议中， 建立TCP/IP后会立即进入发送请求报文。

### 4. 建立TLS连接
建立TCP/IP连接后, 如果发现请求协议是HTTPS， 还需要建立TLS连接。
这个握手过程与TCP类似，是HTTPS 和 TLS 协议里最重要的、最核心的部分。

#### HTTPS

众所周知，HTTP 是不安全的。HTTPS 在其基础上增加了 机密性、完整性、身份认证和不可否认四大安全特性。
它把 HTTP 下层的传输协议由 TCP/IP 换成 SSL/TLS，由 “HTTP over TCP/IP”变成 “HTTP over SSL/TLS”。

那么 HTTPS 是如何做到这些的？答案就在最后的 “s”上。

#### SSL/TLS

SSL 即安全套接层（Secure Sockets Layer），由网景公司与 1994 年发明。
SSL 发展到 v3 时，互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。

目前应用最广泛的 TLS 是 1.2，接下来的讲解都针对的是 TLS1.2。
TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议构成，综合使用了对称加密、非对称加密、身份认证等许多密码学技术。

### 5.HTTP代理

建立TCP/IP连接或TLS连接后， 就可以发起HTTP数据请求了。
不过数据请求的过程中还可能存在一个或多个中间人， 有可能请求不会直接达到源服务器。

代理服务器处理 HTTP 通信过程中的中间位置，对上屏蔽了真实客户端，对下屏蔽了真实服务器。
在这个中间层可以做很多的事情，为 HTTP 协议增加了更多的灵活性。

代理的一个常见的功能就是负载均衡，可以掌握请求分发的“大权”，决定由后面的哪台服务器响应请求。

代理中存在一些常用的负载均衡算法，比如轮询、一致性哈希等，这些算法的目的就是尽量把外部流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能。

> 负载均衡算法
>
> 随机：简单、是否均匀看随机情况。
> 轮询（一般轮询、加权轮询）：相对简单，会考虑机器资源和性能的均衡性。
> 哈希（一般哈希、一致性哈希、带虚拟节点的一致性哈希）：相对复杂，越公平就会越复杂，适当考虑了请求。

我们使用的 CDN 就是一种代理，它可以代替源站服务器响应客户端的请求，通常扮演透明代理和反向代理的角色。
如果 CDN 的调度算法还优秀，还可以找到距离用户最近的节点，大幅度缩短响应时间。

> CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分。

代理相关的知识还有很多，比如缓存代理、负载均衡等，这里就不展开阐述了。

## 3. 处理响应数据

HTTP请求的数据类型， 可能是一个下载类型， 也可能是HTML页面， 浏览器如何区分？ 

答案是Content-Type， Content-Type是 HTTP请求头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型， 然后浏览器会根据 Content-Type的值来决定显示响应体的内容。

需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

所以，不同 Content-Type 的后续处理流程也截然不同。

如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。
但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了

## 4. 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

那什么情况下多个页面会同时运行在一个渲染进程中呢？

要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个

> https://time.geekbang.org
> https://www.geekbang.org
> https://www.geekbang.org:8080

它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。

Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。

总结来说，打开一个新页面采用的渲染进程策略就是: 
- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程；

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

## 5. 提交文档

所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：

- 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
- 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面；

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。


## 6. 渲染阶段

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：

![](https://img.yueluo.club/blog/img/c5f1a594734e16dd910ff529d7cc10c37.png)

按照渲染的时间顺序，流水线可分为如下几个子阶段：
构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

### 1. 构建DOM树

浏览器无法直接理解和使用HTML， 所以需要将HTML转换为浏览器能够理解的结构 - DOM树。

![](https://img.yueluo.club/blog/img/976d447373c8f6cadc7d6cf298784847.png)

### 2. 样式计算

样式计算的目的是为了计算出DOM节点中的每个元素的具体样式, 这个阶段大体可以分为三步来完成。

<b>把CSS转换为浏览器能够理解的结构</b>

css样式来源有三种: 
- 通过 link 引用的外部css资源
- 通过 link 引用内部的css资源
- 元素的style属性内嵌的css

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

你可以在 Chrome 控制台中输入 document.styleSheets 查看其结构。

<b>转换样式表中的属性值， 使其标准化</b>
现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。

![](https://img.yueluo.club/blog/img/b10d4c9f4f1ceef5bd3cdccf7100f27c16.png)

可以看到上图左侧的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

计算出 DOM 树中每个节点的具体样式
现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？

这就涉及到 CSS 的继承规则和层叠规则了。

首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。

```css
body { font-size: 20px }
p {color:blue;}
span  {display: none}
div {font-weight: bold;color:red}
div  p {color:green;}
```

样式表计算效果如图：
![](https://img.yueluo.club/blog/img/50ce95520311a8f2db2a03ccdba107ec2.png)

从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。

### 3. 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。

<b>创建布局树</b>

你可能注意到了 DOM 树还包含了很多不可见的元素， 比如head标签， 还有使用了 display: none属性的元素， 所以在显示之前， 我们还需要额外构建一个只包含可见元素的布局树。

![](https://img.yueluo.club/blog/img/e5e47ddeb7d73844c9bafc41e704713a.png)

从上图可以看出， DOM树中所有不可见的节点都包含到布局树中。

为了构建布局树， 浏览器大体完成了下面这些工作: 

- 遍历DOM树中的所有可见节点， 并把这些节点添加到布局树中。
- 而不可见的节点会被布局树忽略掉， 如head标签下的全部内容， 再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树；

<b>布局计算</b>
现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。
布局的计算过程非常复杂，我们这里先跳过不讲，等到后面再做详细的介绍。


### 4. 分层

现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？

答案依然是否定的。

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层（LayerTree）。
如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。

现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：

![](https://img.yueluo.club/blog/img/6b027f72b14e9ef104f6673776d44cbc6.png)

### 5. 图层绘制

### 6. 栅格化（raster）操作

### 7. 合成与显示

一个完整的渲染流程大致可总结为如下。

渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构；
渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式；
创建布局树，并计算元素的布局信息；
对布局树进行分层，并生成分层树；
为每个图层生成绘制列表，并将其提交到合成线程；
合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图；
合成线程发送绘制图块命令 DrawQuad 给浏览器进程；
浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上；










